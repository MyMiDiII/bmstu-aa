\chapter{Конструкторская часть}

В данном разделе разрабатываются алгоритмы умножения матриц, структура
программы и способы её тестирования, также проводится оценка трудоемкости
каждого из алгоритмов и оптимизация алгоритма Винограда.

\section{Разработка алгоритмов}

В данном подразделе приводятся схемы разработанных алгоритмов, оценка их
трудоемкости, на основе которой производится оптимизация алгоритма Винограда с
последующим описаним алгоритма в виде схемы.

\subsection{Схемы стандартного алгоритма умножения матриц и алгоритма
            Винограда}

На рисунке \ref{scheme:standart} приведена схема стандартного алгоритма
умножения матриц.

\noindent
\scheme{110mm}{standart}{Схема стандартного алгоритма умножения
матриц}{standart}

На рисунках \ref{scheme:Winograd}-\ref{scheme:countMulV} приведена схема
алгоритма Винограда.

\noindent
\scheme{225mm}{Winograd}{Схема алгоритма Винограда умножения матриц}{Winograd}
\noindent
\scheme{105mm}{countMulH}{Схема алгоритма вычисления сумм произведений пар
соседних элементов строк матрицы}{countMulH}
\noindent
\scheme{105mm}{countMulV}{Схема алгоритма вычисления сумм произведений пар
соседних элементов столбцов матрицы}{countMulV}

\section{Оценка трудоемкости алгоритмов}

В данном подразделе производится оценка трудоемкости каждого из алгоритмов.

\subsection{Модель вычислений}

Введем модель вычислений для оценки трудоемкости алгоритмов:
\begin{itemize}[left=\parindent]
    \item операции из списка \ref{op2} имеют трудоемкость 2;
        \begin{equation}\label{op2}
            *,~/,~//,~\%,~*=,~/=,~//=
        \end{equation}

    \item операции из списка \ref{op1} имеют трудоемкость 1;
        \begin{equation}\label{op1}
            =,~+,~-,~+=,~-=,~<,~>,~==,~!=,~>=,~<=,~[],~<<,~>>,~++,~--
        \end{equation}

    \item трyдоемкость оператора выбора \texttt{if} условие \texttt{then} А
        \texttt{else} B рассчитывается по формуле \ref{ifeq}:
        \begin{equation}\label{ifeq}
            f_{if} = f_{условия} +
            \begin{cases}
                f_A, & \text{если условие выполняется;}\\
                f_B, & \text{иначе}
            \end{cases}
        \end{equation}

    \item трудоемкость оператора цикла рассчитывется по формуле \ref{foreq}:
        \begin{equation}\label{foreq}
            f_{\text{for}} = f_{\text{инициализации}} + f_{\text{сравнения}} +
                      N(f_{\text{тела}} + f_{\text{инкремента}} +
                      f_{\text{сравнения}})
        \end{equation}

    \item трyдоемкость вызова функции равна 0.
\end{itemize}

Так как во всех следующих алгоритмах присутствует инциализация матрицы, которая
не является самым трудоемким действием, при оценке трудоемкости она не
учитывается.

\subsection{Трудоемкость стандартного алгоритма умножения матриц}

Трудоемкость стандартного алгоритма умножения матриц считается следующим
образом (циклы обозначаются так же, как и на схеме \ref{scheme:standart}):
\begin{itemize}[left=\parindent]
    \item трудоемкость цикла А вычисляется по формуле \ref{aeq};
        \begin{equation}\label{aeq}
            f_A = 1 + 1 + N(f_B + 1 + 1) = 2 + N(2 + f_B)
        \end{equation}
    \item трудоемкость цикла B вычисляется по формуле \ref{beq};
        \begin{equation}\label{beq}
            f_B = 1 + 1 + M(f_C + 1 + 1) = 2 + M(2 + f_C)
        \end{equation}
    \item трудоемкость цикла C вычисляется по формуле \ref{ceq};
        \begin{equation}\label{ceq}
            f_C = 1 + 1 + P(9 + 1 + 1) = 2 + 11P
        \end{equation}
\end{itemize}

Кроме циклов в стандартном алгоритме нет действий, поэтому трудоемкость
алгоритма равна трудоемкости внешнего цикла А и равна \ref{standarteq}:
    \begin{equation}\label{standarteq}
        f_{standart} = 2 + N(2 + 2 + M(2 + 2 + 11P)) = 11NMP + 4MN + 4N + 2 
    \end{equation}


\subsection{Трудоемкость алгоритма умножения матриц Винограда}

Трудоемкость алгоритма умножения матриц Винограда считается следующим образом:
\begin{itemize}[left=\parindent]
    \item трудоемкость инициализации массивов mulH и mulV равна \ref{miniteq};
        \begin{equation}\label{miniteq}
            f_{init} = N + M
        \end{equation}

    \item трудоемкость заполнения массива mulH вычисляется по формуле
        \ref{mulHeq} (обоначение циклов как на схеме \ref{scheme:countMulH});
        \begin{multline}\label{mulHeq}
            f_{mulH} = f_A = 2 + N(2 + f_B) = \\ = 2 + N(2 +
                       1 + 3 + \frac{P}{2}(3 + 1 + 15)) = \\ = 2 +
                       N(6 + \frac{19P}{2}) = 9.5PN + 6N + 2
        \end{multline}

    \item трудоемкость заполнения массива mulV вычисляется по формуле
        \ref{mulVeq} (обоначение циклов как на схеме \ref{scheme:countMulV});
        \begin{multline}\label{mulVeq}
            f_{mulV} = f_A = 2 + M(2 + f_B) = \\ = 2 +
            M(2 + 1 + 3 + \frac{P}{2}(1 + 3 + 15)) = \\ = 2 + M(6 +
            \frac{19P}{2}) = 9.5MP + 6M + 2
        \end{multline}

    \item трудоемкость основной части алгоритма для лучшего случая, то есть
        когда P -- четное, равна \ref{winmainbesteq} (обознаяение циклов как на
        схеме \ref{scheme:Winograd});
        \begin{multline}\label{winmainbesteq}
            f_{main}^{\wedge} = f_A = 2 + N(2 + f_B) = \\ =  2 + N(2 + 2 + M(2
            + 7 + f_c + 3)) = \\ = 2 + N(4 + M(12 + 4 + \frac{P}{2}(4 + 28))) =
            \\ = 16NMP + 16NM + 4N + 2
        \end{multline}

    \item трудоемкость основной части алгоритма для худшего случая, то есть
        когда P -- нечетное, равна \ref{winmainworseeq} (обознаяение циклов как
        на схеме \ref{scheme:Winograd});
        \begin{multline}\label{winmainworseeq}
            f_{main}^{\vee} = f_A = 2 + N(2 + f_B) = \\ =  2 + N(2 + 2 + M(2 +
            7 + f_c + 3 + 14)) = \\ = 2 + N(4 + M(26 + 4 + \frac{P}{2}(4 +
            28))) = \\ = 16NMP + 30NM + 4N + 2
        \end{multline}
\end{itemize}

Таким образом, трудоемкость алгоритма Винограда равна \ref{winogradbest} для
лучшего случая, \ref{winogradworse} -- для худшего.
    \begin{multline}\label{winogradbest}
        f_{Winograd}^{\wedge} = 16NMP + 16NM + 4N + 2 + \\
                                + 9.5MP + 6M + 2
                                + 9.5PN + 6N + 2 + N + M = \\
                                = 16NMP + 16NM + 9.5MP
                                + 9.5PN + 11N + 7M + 6
    \end{multline}
    \begin{multline}\label{winogradworse}
        f_{Winograd}^{\vee} = 16NMP + 30NM + 4N + 2 + \\
                                + 9.5MP + 6M + 2
                                + 9.5PN + 6N + 2 + N + M = \\
                                = 16NMP + 30NM + 9.5MP
                                + 9.5PN + 11N + 7M + 6
    \end{multline}

\section{Оптимизация алгоритма Винограда}

Как видно по вычисленным трудоемкостям алгоритмов (формулы \ref{standarteq} и
\ref{winogradbest}), трудоемкость алгоритма умножения матриц не уменьшилась, а
даже увеличилась, связано это с тем, что с вынесением предварительных
вычислений возросло количество таких дорогостоящих операций, как умножение и
деление. Чтобы получить выигрыш от предварительных вычислений, необходимо
оптимизировать алгоритм, для чего используем следующие типы оптимизации:
\begin{itemize}[left=\parindent]
    \item большинство производимых умножений и делений происходит на 2, поэтому
          заменим их на побитовый сдвиг влево и вправо соответственно;
    \item заменим выражения вида \texttt{x = x + y} на выражения вида \texttt{x
        += y}, а выражения вида \texttt{x = x - y} на выражения вида \texttt{x
        -= y}, избавившись худшем случае от одной операции при каждой замене;
    \item операции умножения можно убрать, сделав в циклах по \texttt{k} шаг 2.
\end{itemize}

\subsection{Схема оптимизированного алгоритма Винограда}

Применив типы оптимизации, описанные выше, получим схему оптимизированного
алгоритма Винограда, представленную на рисунках \ref{scheme:optWin} -
\ref{scheme:optCountMulV}.

\noindent
\scheme{225mm}{optWinograd}{Схема оптимизированного алгоритма Винограда
                            умножения матриц}{optWin}
\noindent
\scheme{105mm}{optCountMulH}{Схема оптимизированного алгоритма вычисления сумм
произведений пар соседних элементов строк матрицы}{optCountMulH}
\noindent
\scheme{105mm}{optCountMulV}{Схема оптимизированного алгоритма вычисления сумм
произведений пар соседних элементов столбцов матрицы}{optCountMulV}

\subsection{Трудоемкость оптимизированного алгоритма Винограда}

Рассчитаем трудоемкость оптимизированного алгоритма Винограда аналогично
неоптимизированному случаю:
\begin{itemize}[left=\parindent]
    \item трудоемкость инициализации массивов mulH и mulV равна \ref{ominiteq};
        \begin{equation}\label{ominiteq}
            f_{init} = N + M
        \end{equation}

    \item трудоемкость заполнения массива mulH вычисляется по формуле
        \ref{optMulHeq} (обоначение циклов как на схеме
        \ref{scheme:optCountMulH});
        \begin{multline}\label{optMulHeq}
            f_{optMulH} = f_A = 2 + N(2 + f_B) = \\ = 2 + N(2 + 1 + 2 +
            \frac{P}{2}(3 + 9)) = \\ = 2 + N(5 + \frac{12P}{2}) = 6PN
            + 5N + 2
        \end{multline}

    \item трудоемкость заполнения массива mulV вычисляется по формуле
        \ref{optMulVeq} (обоначение циклов как на схеме
        \ref{scheme:optCountMulV});
        \begin{multline}\label{optMulVeq}
            f_{optMulV} = f_A = 2 + M(2 + f_B) = \\ = 2 + M(2 + 1 + 2 +
            \frac{P}{2}(3 + 9)) = \\ = 2 + M(5 + \frac{12P}{2}) = 6MP + 5M + 2
        \end{multline}

    \item трудоемкость основной части алгоритма для лучшего случая, то есть
        когда P -- четное, равна \ref{owinmainbesteq} (обознаяение циклов как на
        схеме \ref{scheme:optWin});
        \begin{multline}\label{owinmainbesteq}
            f_{optMain}^{\wedge} = f_A = 2 + N(2 + f_B) = \\ =  2 + N(2 + 2 +
            M(2 + 6 + f_c + 3)) = \\ = 2 + N(4 + M(11 + 3 + \frac{P}{2}(3 +
            17))) = \\ = 10NMP + 14NM + 4N + 2
        \end{multline}

    \item трудоемкость основной части алгоритма для худшего случая, то есть
        когда P -- нечетное, равна \ref{owinmainworseeq} (обознаяение циклов как
        на схеме \ref{scheme:optWin});
        \begin{multline}\label{owinmainworseeq}
            f_{optMain}^{\vee} = f_A = 2 + N(2 + f_B) = \\ =  2 + N(2 + 2 + M(2 +
            6 + f_c + 3 + 11)) = \\ = 2 + N(4 + M(22 + 3 + \frac{P}{2}(3 +
            17))) = \\ = 10NMP + 25NM + 4N + 2
        \end{multline}
\end{itemize}

Таким образом, трудоемкость оптимизированного алгоритма Винограда равна
\ref{optwinogradbest} для лучшего случая, \ref{optwinogradworse} -- для
худшего.
    \begin{multline}\label{optwinogradbest}
        f_{optWinograd}^{\wedge} = 10NMP + 14NM + 4N + 2 + \\
                                + 6MP + 5M + 2
                                + 6PN + 5N + 2 + N + M = \\
                                = 10NMP + 14NM + 6MP
                                + 6PN + 10N + 6M + 6
    \end{multline}
    \begin{multline}\label{optwinogradworse}
        f_{optWinograd}^{\vee} = 10NMP + 25NM + 4N + 2 + \\
                              + 6MP + 5M + 2
                              + 6PN + 5N + 2 + N + M = \\
                              = 10NMP + 25NM + 6MP
                              + 6PN + 10N + 6M + 6
    \end{multline}

\section{Структура разрабатываемого ПО}

Для реализации разрабатываемого программного обеспечения будет использоваться
метод структурного программирования. Каждый из алгоритмов будет представлен
отдельной функцией, при необходимости будут выделены подпрограммы для какждой
из них. Также будут реализованы функции для ввода-вывода
и функция, вызывающая все подпрограммы для связности и полноценности
программы.

\section{Классы эквивалентности при тестировании}

Для тестирования программного обеспечения во множестве тестов будут выделены
следующие классы эквивалентности:
\begin{itemize}[left=\parindent]
    \item количество столбцов первой матрицы не равно количеству строк второй;
    \item квадратные матрицы;
    \item произвольные матрицы с определенной операцией умножения;
    \item умножение матрицы на обратную;
    \item умножение на нулевую матрицу;
    \item умножение на единичную матрицу.
\end{itemize}

\section{Вывод}

В данном разделе были разработаны алгоритмы умножения матриц: стандартный и Винограда, -- также была произведена оценка трудоемкостей алгоритмов и оптимизация алгоритма Винограда. Для дальшейшей проверки правильности работы программы были выделены классы эквавалентности тестов.
