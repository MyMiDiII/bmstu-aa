\chapter{Конструкторская часть}

В данном разделе разрабатываются алгоритмы сортировки, структура программы и
способы её тестироваия, также проводится оценка трудоемкости каждого из
алгоритмов.

\section{Разработка алгоритмов}

На рисунке \ref{scheme:insertion} представлена схема алгоритма сортировки
вставками, на рисунке \ref{scheme:shaker} --- схема алгоритма сортировки
перемешиванием, на рисунке \ref{scheme:selection} --- схема алгоритма сортировки
выбором.

\noindent
\scheme{180mm}{insertionSort}{Схема алгоритма сортировки вставками}{insertion}
\noindent
\scheme{180mm}{shakerSort}{Схема алгоритма сортировки перемешиванием}{shaker}
\noindent
\scheme{180mm}{selectionSort}{Схема алгоритма сортировки выбором}{selection}

\clearpage
\section{Оценка трудоемкости алгоритмов}

В данном подразделе производится оценка трудоемкости каждого из алгоритмов.

\subsection{Модель вычислений}

Введем модель вычислений для оценки трудоемкости алгоритмов:
\begin{itemize}[left=\parindent]
    \item операции из списка \ref{op2} имеют трудоемкость 2;
        \begin{equation}\label{op2}
            *,~/,~//,~\%,~*=,~/=,~//=
        \end{equation}

    \item операции из списка \ref{op1} имеют трудоемкость 1;
        \begin{equation}\label{op1}
            \begin{aligned}
                =,~+,~-,~+=,~-=,~<,~>,~==,~!=,\\
                ~>=, ~<=,~[],~<<,~>>,~++,~--,and,or
            \end{aligned}
        \end{equation}

    \item трyдоемкость оператора выбора \texttt{if} условие \texttt{then} А
        \texttt{else} B рассчитывается по формуле \ref{ifeq}:
        \begin{equation}\label{ifeq}
            f_{if} = f_{условия} +
            \begin{cases}
                f_A, & \text{если условие выполняется;}\\
                f_B, & \text{иначе}
            \end{cases}
        \end{equation}

    \item трудоемкость оператора цикла рассчитывется по формуле \ref{foreq}:
        \begin{equation}\label{foreq}
            f_{\text{for}} = f_{\text{инициализации}} + f_{\text{сравнения}} +
                      N(f_{\text{тела}} + f_{\text{инкремента}} +
                      f_{\text{сравнения}})
        \end{equation}

    \item трyдоемкость вызова функции равна 0.
\end{itemize}

\subsection{Алгоритм сортировки вставками}

В лучшем случае алгоритму подается на вход упорядоченная последовательность.
При таких входных данных цикл $A$ отрабатывает $N - 1$ раз, где $N = size$, а
внутренний цикл $B$ на каждой итерации осуществляет только инициализацию и
проверку условия, которое оказывается ложным, из-за чего тело не выполняется. 
Таким образом, в лучшем случае трудоемкость алгоритма сортировки вставками
равна (формула \ref{eq:bestinsert}):
    \begin{equation}\label{eq:bestinsert}
        f^{\wedge} = 2 + (N - 1)(2 + 2 + 4 + 3) = 13N - 11=O(N)    
    \end{equation}

В худшем случае алгритму подается на вход последовательность, упорядоченная в
обратном порядке. При таких входных данных цикл $B$ отрабатывает в среднем
$\frac{N+2}{2}$. Таким образом, в худшем случае трудоемкость алгоритма
сортировки вставками равна (формула \ref{eq:worstinsert}):
    \begin{equation}\label{eq:worstinsert}
        f^{\vee} = 2 + (N - 1)(2 + 2 + 6 + \frac{N+2}{2}(5 + 4) + 3)
                   = \frac{9}{2}N^2 + \frac{35}{2}N - 20 = O(N^2)
    \end{equation}

\subsection{Алгоритм сортировки перемешиванием}

В лучшем случае алгоритму подается на вход упорядоченная последовательность.
При таких входных данных первый внутренний цикл $A$ осуществлет полный проход
по последовательность в одну сторону и не находит обменов соседний элементов,
поэтому на перой же итерации внешнего цикла правая граница становится равной
левой границе, из-за чего второй внутренний цикл $B$ не отрабатывает, произведя
только ининциализацию и одну проверку условия, а внешний цикл завершает свою
работу после первой итерации. Таким образом, в лучшем случае трудоемкость
алгоритма сортировки перемешиваним равна (формула \ref{eq:bestshaker}):
    \begin{equation}\label{eq:bestshaker}
        f^{\wedge} = 4 + 1 + 2 + (N - 1)(2 + 4) + 1 + 2 + 1 + 1 =
                     6N + 6 = O(N)
    \end{equation}

В худшем случае алгоритму подается на вход упорядоченная в обратном порядке
последовательность. Внешний цикл отрабатывает $\frac{N}{2}$ раз, так как за
одну итерацию на свое место ставятся 2 элемента. Количество итераций каждого
цикла зависит от четности размера подаваемой последовательнсти, если $N$ ---
четно, то цикл $A$ отработает $\frac{N - 1 + 1}{2}$ итераций, а цикл $B$ ---
$\frac{N - 2 + 1}{2}$, если $N$ --- нечетно, то цикл $A$ отработает $\frac{N -
1 + 2}{2}$ итераций, а цикл $B$ --- $\frac{N - 2}{2}$, однако и в том, и другом
случае в общем два цикла отработают $\frac{2N-1}{2}$ итераций, а так как
сложность тел обоих циклов одинаковая при вычислениях можно сразу пользоваться
общим числом итераций. Таким образом, в худшем случае трудоемкость алгоритма
сортировки перемешиванием равна (формула \ref{eq:worstshaker}):
    \begin{multline}\label{eq:worstshaker}
        f^{\vee} = 4 + \frac{N}{2}(1 + 2 + 1 + 2 + 1 + \frac{2N-1}{2}(2 + 4 + 9
                   + 1)) =\\= 4 + \frac{N}{2}(16N - 1) = 8N^2-\frac{N}{2} + 4 =
                   O(N^2)
    \end{multline}

\subsection{Алгоритм сортировки выбором}

В любом случае в алгоритме сортировки выбором внешний цикл $A$ выполняет
$N-1$ итераций, а внутренний цикл в среднем $\frac{N}{2}$ итерации.

В лучшем случае на вход алгоритму подается упорядоченная последовательность.
При таких входных данных никогда не выполняется блок по ветке \texttt{then}
условия. Таким образом, в лучшем случае трудоемкость алгоритма сортировки
выбором равна (формула \ref{eq:bestselect}):
    \begin{multline}\label{eq:bestselect}
        f^{\wedge} = 3 + (N - 1)(3 + 1 + 3 + \frac{N}{2}(2 + 3) + 7) = \\
                     = 3 + (N - 1)(14 + \frac{5}{2}N) =
                     \frac{5}{2}N^2 + \frac{23}{2}N - 11 = O(N^2)
    \end{multline}

В худшем случае на вход алгоритму подается упорядоченная в обратном порядке
последовательность. При таких входных данных всегда выполняется блок по
ветке \texttt{then} условия. Таким образом, в лучшем случае трудоемкость
алгоритма сортировки выбором равна (формула \ref{eq:worstselect}):
    \begin{multline}\label{eq:worstselect}
        f^{\wedge} = 3 + (N - 1)(3 + 1 + 3 + \frac{N}{2}(2 + 3 + 1) + 7) = \\
                     = 3 + (N - 1)(14 + 3N) =
                     3N^2 + 11N - 11 = O(N^2)
    \end{multline}


\section{Структура разрабатываемого ПО}

Для реализации разрабатываемого программного обеспечения будет использоваться
метод структурного программирования. Каждый из алгоритмов будет представлен
отдельной функцией, при необходимости будут выделены подпрограммы для каждой из
них. Также будут реализованы функции для ввода-вывода и функция, вызывающая все
подпрограммы для связности и полноценности программы.

\section{Классы эквивалентности при тестировании}

Для тестирования программного обеспечения во множестве тестов будут выделены
следующие классы эквивалентности:
\begin{itemize}[left=\parindent]
    \item пустой массив; 
    \item упорядоченный массив четной длины;
    \item упорядоченный массив нечетной длины;
    \item упорядоченный в обратном порядке массив четной длины;
    \item упорядоченный в обратном порядке массив нечетной длины;
    \item случайный массив;
    \item массив из одного элемента.
\end{itemize}

\section{Вывод}

В данном разделе были разработаны алгоритмы сортировки вставками,
перемешиванием и выбором, также была произведен оценка трудоемкостей
алгоритмов. Для дальнейшей проверки правильности работы программы были выделены
классы эквивалентности тестов.
